"use strict";var _interopRequireDefault3 = require("@babel/runtime/helpers/interopRequireDefault");var _interopRequireDefault2 = _interopRequireDefault3(require("@babel/runtime/helpers/interopRequireDefault"));Object.defineProperty(exports, "__esModule", { value: true });var _ejson = require("ejson");var EJSON = (0, _interopRequireDefault2["default"])(_ejson)["default"];

var DiffSequence = {};exports["default"] =
DiffSequence;
var hasOwn = Object.prototype.hasOwnProperty;

function isObjEmpty(obj) {
  for (var key in Object(obj)) {
    if (hasOwn.call(obj, key)) {
      return false;
    }
  }
  return true;
}

// ordered: bool.
// old_results and new_results: collections of documents.
//    if ordered, they are arrays.
//    if unordered, they are IdMaps
DiffSequence.diffQueryChanges = function (ordered, oldResults, newResults, observer, options) {
  if (ordered)
  DiffSequence.diffQueryOrderedChanges(
  oldResults, newResults, observer, options);else

  DiffSequence.diffQueryUnorderedChanges(
  oldResults, newResults, observer, options);
};

DiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults, observer, options) {
  options = options || {};
  var projectionFn = options.projectionFn || EJSON.clone;

  if (observer.movedBefore) {
    throw new Error("_diffQueryUnordered called with a movedBefore observer!");
  }

  newResults.forEach(function (newDoc, id) {
    var oldDoc = oldResults.get(id);
    if (oldDoc) {
      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {
        var projectedNew = projectionFn(newDoc);
        var projectedOld = projectionFn(oldDoc);
        var changedFields = DiffSequence.makeChangedFields(projectedNew, projectedOld);
        if (!isObjEmpty(changedFields)) {
          observer.changed(id, changedFields);
        }
      }
    } else if (observer.added) {
      var fields = projectionFn(newDoc);
      delete fields._id;
      observer.added(newDoc._id, fields);
    }
  });

  if (observer.removed) {
    oldResults.forEach(function (oldDoc, id) {
      if (!newResults.has(id))
      observer.removed(id);
    });
  }
};

DiffSequence.diffQueryOrderedChanges = function (old_results, new_results, observer, options) {
  options = options || {};
  var projectionFn = options.projectionFn || EJSON.clone;

  var new_presence_of_id = {};
  new_results.forEach(function (doc) {
    new_presence_of_id[doc._id] = true;
  });

  var old_index_of_id = {};
  old_results.forEach(function (doc, i) {
    old_index_of_id[doc._id] = i;
  });

  // ALGORITHM:
  //
  // To determine which docs should be considered "moved" (and which
  // merely change position because of other docs moving) we run
  // a "longest common subsequence" (LCS) algorithm.  The LCS of the
  // old doc IDs and the new doc IDs gives the docs that should NOT be
  // considered moved.

  // To actually call the appropriate callbacks to get from the old state to the
  // new state:

  // First, we call removed() on all the items that only appear in the old
  // state.

  // Then, once we have the items that should not move, we walk through the new
  // results array group-by-group, where a "group" is a set of items that have
  // moved, anchored on the end by an item that should not move.  One by one, we
  // move each of those elements into place "before" the anchoring end-of-group
  // item, and fire changed events on them if necessary.  Then we fire a changed
  // event on the anchor, and move on to the next group.  There is always at
  // least one group; the last group is anchored by a virtual "null" id at the
  // end.

  // Asymptotically: O(N k) where k is number of ops, or potentially
  // O(N log N) if inner loop of LCS were made to be binary search.


  //////// LCS (longest common sequence, with respect to _id)
  // (see Wikipedia article on Longest Increasing Subsequence,
  // where the LIS is taken of the sequence of old indices of the
  // docs in new_results)
  //
  // unmoved: the output of the algorithm; members of the LCS,
  // in the form of indices into new_results
  var unmoved = [];
  // max_seq_len: length of LCS found so far
  var max_seq_len = 0;
  // seq_ends[i]: the index into new_results of the last doc in a
  // common subsequence of length of i+1 <= max_seq_len
  var N = new_results.length;
  var seq_ends = new Array(N);
  // ptrs:  the common subsequence ending with new_results[n] extends
  // a common subsequence ending with new_results[ptr[n]], unless
  // ptr[n] is -1.
  var ptrs = new Array(N);
  // virtual sequence of old indices of new results
  var old_idx_seq = function old_idx_seq(i_new) {
    return old_index_of_id[new_results[i_new]._id];
  };
  // for each item in new_results, use it to extend a common subsequence
  // of length j <= max_seq_len
  for (var i = 0; i < N; i++) {
    if (old_index_of_id[new_results[i]._id] !== undefined) {
      var j = max_seq_len;
      // this inner loop would traditionally be a binary search,
      // but scanning backwards we will likely find a subseq to extend
      // pretty soon, bounded for example by the total number of ops.
      // If this were to be changed to a binary search, we'd still want
      // to scan backwards a bit as an optimization.
      while (j > 0) {
        if (old_idx_seq(seq_ends[j - 1]) < old_idx_seq(i))
        break;
        j--;
      }

      ptrs[i] = j === 0 ? -1 : seq_ends[j - 1];
      seq_ends[j] = i;
      if (j + 1 > max_seq_len)
      max_seq_len = j + 1;
    }
  }

  // pull out the LCS/LIS into unmoved
  var idx = max_seq_len === 0 ? -1 : seq_ends[max_seq_len - 1];
  while (idx >= 0) {
    unmoved.push(idx);
    idx = ptrs[idx];
  }
  // the unmoved item list is built backwards, so fix that
  unmoved.reverse();

  // the last group is always anchored by the end of the result list, which is
  // an id of "null"
  unmoved.push(new_results.length);

  old_results.forEach(function (doc) {
    if (!new_presence_of_id[doc._id])
    observer.removed && observer.removed(doc._id);
  });

  // for each group of things in the new_results that is anchored by an unmoved
  // element, iterate through the things before it.
  var startOfGroup = 0;
  unmoved.forEach(function (endOfGroup) {
    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;
    var oldDoc, newDoc, fields, projectedNew, projectedOld;
    for (var i = startOfGroup; i < endOfGroup; i++) {
      newDoc = new_results[i];
      if (!hasOwn.call(old_index_of_id, newDoc._id)) {
        fields = projectionFn(newDoc);
        delete fields._id;
        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);
        observer.added && observer.added(newDoc._id, fields);
      } else {
        // moved
        oldDoc = old_results[old_index_of_id[newDoc._id]];
        projectedNew = projectionFn(newDoc);
        projectedOld = projectionFn(oldDoc);
        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);
        if (!isObjEmpty(fields)) {
          observer.changed && observer.changed(newDoc._id, fields);
        }
        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);
      }
    }
    if (groupId) {
      newDoc = new_results[endOfGroup];
      oldDoc = old_results[old_index_of_id[newDoc._id]];
      projectedNew = projectionFn(newDoc);
      projectedOld = projectionFn(oldDoc);
      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);
      if (!isObjEmpty(fields)) {
        observer.changed && observer.changed(newDoc._id, fields);
      }
    }
    startOfGroup = endOfGroup + 1;
  });


};


// General helper for diff-ing two objects.
// callbacks is an object like so:
// { leftOnly: function (key, leftValue) {...},
//   rightOnly: function (key, rightValue) {...},
//   both: function (key, leftValue, rightValue) {...},
// }
DiffSequence.diffObjects = function (left, right, callbacks) {
  Object.keys(left).forEach(function (key) {
    var leftValue = left[key];
    if (hasOwn.call(right, key)) {
      callbacks.both && callbacks.both(key, leftValue, right[key]);
    } else {
      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);
    }
  });

  if (callbacks.rightOnly) {
    Object.keys(right).forEach(function (key) {
      var rightValue = right[key];
      if (!hasOwn.call(left, key)) {
        callbacks.rightOnly(key, rightValue);
      }
    });
  }
};

DiffSequence.diffMaps = function (left, right, callbacks) {
  left.forEach(function (leftValue, key) {
    if (right.has(key)) {
      callbacks.both && callbacks.both(key, leftValue, right.get(key));
    } else {
      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);
    }
  });

  if (callbacks.rightOnly) {
    right.forEach(function (rightValue, key) {
      if (!left.has(key)) {
        callbacks.rightOnly(key, rightValue);
      }
    });
  }
};


DiffSequence.makeChangedFields = function (newDoc, oldDoc) {
  var fields = {};
  DiffSequence.diffObjects(oldDoc, newDoc, {
    leftOnly: function leftOnly(key, value) {
      fields[key] = undefined;
    },
    rightOnly: function rightOnly(key, value) {
      fields[key] = value;
    },
    both: function both(key, leftValue, rightValue) {
      if (!EJSON.equals(leftValue, rightValue))
      fields[key] = rightValue;
    } });

  return fields;
};

DiffSequence.applyChanges = function (doc, changeFields) {
  Object.keys(changeFields).forEach(function (key) {
    var value = changeFields[key];
    if (typeof value === "undefined") {
      delete doc[key];
    } else {
      doc[key] = value;
    }
  });
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EaWZmU2VxdWVuY2UuanMiXSwibmFtZXMiOlsiRUpTT04iLCJEaWZmU2VxdWVuY2UiLCJoYXNPd24iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzT2JqRW1wdHkiLCJvYmoiLCJrZXkiLCJjYWxsIiwiZGlmZlF1ZXJ5Q2hhbmdlcyIsIm9yZGVyZWQiLCJvbGRSZXN1bHRzIiwibmV3UmVzdWx0cyIsIm9ic2VydmVyIiwib3B0aW9ucyIsImRpZmZRdWVyeU9yZGVyZWRDaGFuZ2VzIiwiZGlmZlF1ZXJ5VW5vcmRlcmVkQ2hhbmdlcyIsInByb2plY3Rpb25GbiIsImNsb25lIiwibW92ZWRCZWZvcmUiLCJFcnJvciIsImZvckVhY2giLCJuZXdEb2MiLCJpZCIsIm9sZERvYyIsImdldCIsImNoYW5nZWQiLCJlcXVhbHMiLCJwcm9qZWN0ZWROZXciLCJwcm9qZWN0ZWRPbGQiLCJjaGFuZ2VkRmllbGRzIiwibWFrZUNoYW5nZWRGaWVsZHMiLCJhZGRlZCIsImZpZWxkcyIsIl9pZCIsInJlbW92ZWQiLCJoYXMiLCJvbGRfcmVzdWx0cyIsIm5ld19yZXN1bHRzIiwibmV3X3ByZXNlbmNlX29mX2lkIiwiZG9jIiwib2xkX2luZGV4X29mX2lkIiwiaSIsInVubW92ZWQiLCJtYXhfc2VxX2xlbiIsIk4iLCJsZW5ndGgiLCJzZXFfZW5kcyIsIkFycmF5IiwicHRycyIsIm9sZF9pZHhfc2VxIiwiaV9uZXciLCJ1bmRlZmluZWQiLCJqIiwiaWR4IiwicHVzaCIsInJldmVyc2UiLCJzdGFydE9mR3JvdXAiLCJlbmRPZkdyb3VwIiwiZ3JvdXBJZCIsImFkZGVkQmVmb3JlIiwiZGlmZk9iamVjdHMiLCJsZWZ0IiwicmlnaHQiLCJjYWxsYmFja3MiLCJrZXlzIiwibGVmdFZhbHVlIiwiYm90aCIsImxlZnRPbmx5IiwicmlnaHRPbmx5IiwicmlnaHRWYWx1ZSIsImRpZmZNYXBzIiwidmFsdWUiLCJhcHBseUNoYW5nZXMiLCJjaGFuZ2VGaWVs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QUFyQixFQUFrQztBQUM5QixhQUFPaEMsR0FBRyxDQUFDakMsR0FBRCxDQUFWO0FBQ0gsS0FGRCxNQUVPO0FBQ0hpQyxNQUFBQSxHQUFHLENBQUNqQyxHQUFELENBQUgsR0FBV2lFLEtBQVg7QUFDSDtBQUNKLEdBUEQ7QUFRSCxDQVREIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVKU09OIGZyb20gJ2Vqc29uJztcblxuY29uc3QgRGlmZlNlcXVlbmNlID0ge307XG5leHBvcnQgZGVmYXVsdCBEaWZmU2VxdWVuY2U7XG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBpc09iakVtcHR5KG9iaikge1xuICAgIGZvciAobGV0IGtleSBpbiBPYmplY3Qob2JqKSkge1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIG9yZGVyZWQ6IGJvb2wuXG4vLyBvbGRfcmVzdWx0cyBhbmQgbmV3X3Jlc3VsdHM6IGNvbGxlY3Rpb25zIG9mIGRvY3VtZW50cy5cbi8vICAgIGlmIG9yZGVyZWQsIHRoZXkgYXJlIGFycmF5cy5cbi8vICAgIGlmIHVub3JkZXJlZCwgdGhleSBhcmUgSWRNYXBzXG5EaWZmU2VxdWVuY2UuZGlmZlF1ZXJ5Q2hhbmdlcyA9IGZ1bmN0aW9uIChvcmRlcmVkLCBvbGRSZXN1bHRzLCBuZXdSZXN1bHRzLG9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9yZGVyZWQpXG4gICAgICAgIERpZmZTZXF1ZW5jZS5kaWZmUXVlcnlPcmRlcmVkQ2hhbmdlcyhcbiAgICAgICAgICAgIG9sZFJlc3VsdHMsIG5ld1Jlc3VsdHMsIG9ic2VydmVyLCBvcHRpb25zKTtcbiAgICBlbHNlXG4gICAgICAgIERpZmZTZXF1ZW5jZS5kaWZmUXVlcnlVbm9yZGVyZWRDaGFuZ2VzKFxuICAgICAgICAgICAgb2xkUmVzdWx0cywgbmV3UmVzdWx0cywgb2JzZXJ2ZXIsIG9wdGlvbnMpO1xufTtcblxuRGlmZlNlcXVlbmNlLmRpZmZRdWVyeVVub3JkZXJlZENoYW5nZXMgPSBmdW5jdGlvbiAob2xkUmVzdWx0cywgbmV3UmVzdWx0cywgIG9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgbGV0IHByb2plY3Rpb25GbiA9IG9wdGlvbnMucHJvamVjdGlvbkZuIHx8IEVKU09OLmNsb25lO1xuXG4gICAgaWYgKG9ic2VydmVyLm1vdmVkQmVmb3JlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9kaWZmUXVlcnlVbm9yZGVyZWQgY2FsbGVkIHdpdGggYSBtb3ZlZEJlZm9yZSBvYnNlcnZlciFcIik7XG4gICAgfVxuXG4gICAgbmV3UmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdEb2MsIGlkKSB7XG4gICAgICAgIGxldCBvbGREb2MgPSBvbGRSZXN1bHRzLmdldChpZCk7XG4gICAgICAgIGlmIChvbGREb2MpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jaGFuZ2VkICYmICFFSlNPTi5lcXVhbHMob2xkRG9jLCBuZXdEb2MpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb2plY3RlZE5ldyA9IHByb2plY3Rpb25GbihuZXdEb2MpO1xuICAgICAgICAgICAgICAgIGxldCBwcm9qZWN0ZWRPbGQgPSBwcm9qZWN0aW9uRm4ob2xkRG9jKTtcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZEZpZWxkcyA9IERpZmZTZXF1ZW5jZS5tYWtlQ2hhbmdlZEZpZWxkcyhwcm9qZWN0ZWROZXcsIHByb2plY3RlZE9sZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEgaXNPYmpFbXB0eShjaGFuZ2VkRmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jaGFuZ2VkKGlkLCBjaGFuZ2VkRmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JzZXJ2ZXIuYWRkZWQpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBwcm9qZWN0aW9uRm4obmV3RG9jKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHMuX2lkO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuYWRkZWQobmV3RG9jLl9pZCwgZmllbGRzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG9ic2VydmVyLnJlbW92ZWQpIHtcbiAgICAgICAgb2xkUmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChvbGREb2MsIGlkKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Jlc3VsdHMuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5yZW1vdmVkKGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuRGlmZlNlcXVlbmNlLmRpZmZRdWVyeU9yZGVyZWRDaGFuZ2VzID0gZnVuY3Rpb24gKG9sZF9yZXN1bHRzLCBuZXdfcmVzdWx0cywgb2JzZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcHJvamVjdGlvbkZuID0gb3B0aW9ucy5wcm9qZWN0aW9uRm4gfHwgRUpTT04uY2xvbmU7XG5cbiAgICBsZXQgbmV3X3ByZXNlbmNlX29mX2lkID0ge307XG4gICAgbmV3X3Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIG5ld19wcmVzZW5jZV9vZl9pZFtkb2MuX2lkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBsZXQgb2xkX2luZGV4X29mX2lkID0ge307XG4gICAgb2xkX3Jlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAoZG9jLCBpKSB7XG4gICAgICAgIG9sZF9pbmRleF9vZl9pZFtkb2MuX2lkXSA9IGk7XG4gICAgfSk7XG5cbiAgICAvLyBBTEdPUklUSE06XG4gICAgLy9cbiAgICAvLyBUbyBkZXRlcm1pbmUgd2hpY2ggZG9jcyBzaG91bGQgYmUgY29uc2lkZXJlZCBcIm1vdmVkXCIgKGFuZCB3aGljaFxuICAgIC8vIG1lcmVseSBjaGFuZ2UgcG9zaXRpb24gYmVjYXVzZSBvZiBvdGhlciBkb2NzIG1vdmluZykgd2UgcnVuXG4gICAgLy8gYSBcImxvbmdlc3QgY29tbW9uIHN1YnNlcXVlbmNlXCIgKExDUykgYWxnb3JpdGhtLiAgVGhlIExDUyBvZiB0aGVcbiAgICAvLyBvbGQgZG9jIElEcyBhbmQgdGhlIG5ldyBkb2MgSURzIGdpdmVzIHRoZSBkb2NzIHRoYXQgc2hvdWxkIE5PVCBiZVxuICAgIC8vIGNvbnNpZGVyZWQgbW92ZWQuXG5cbiAgICAvLyBUbyBhY3R1YWxseSBjYWxsIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3MgdG8gZ2V0IGZyb20gdGhlIG9sZCBzdGF0ZSB0byB0aGVcbiAgICAvLyBuZXcgc3RhdGU6XG5cbiAgICAvLyBGaXJzdCwgd2UgY2FsbCByZW1vdmVkKCkgb24gYWxsIHRoZSBpdGVtcyB0aGF0IG9ubHkgYXBwZWFyIGluIHRoZSBvbGRcbiAgICAvLyBzdGF0ZS5cblxuICAgIC8vIFRoZW4sIG9uY2Ugd2UgaGF2ZSB0aGUgaXRlbXMgdGhhdCBzaG91bGQgbm90IG1vdmUsIHdlIHdhbGsgdGhyb3VnaCB0aGUgbmV3XG4gICAgLy8gcmVzdWx0cyBhcnJheSBncm91cC1ieS1ncm91cCwgd2hlcmUgYSBcImdyb3VwXCIgaXMgYSBzZXQgb2YgaXRlbXMgdGhhdCBoYXZlXG4gICAgLy8gbW92ZWQsIGFuY2hvcmVkIG9uIHRoZSBlbmQgYnkgYW4gaXRlbSB0aGF0IHNob3VsZCBub3QgbW92ZS4gIE9uZSBieSBvbmUsIHdlXG4gICAgLy8gbW92ZSBlYWNoIG9mIHRob3NlIGVsZW1lbnRzIGludG8gcGxhY2UgXCJiZWZvcmVcIiB0aGUgYW5jaG9yaW5nIGVuZC1vZi1ncm91cFxuICAgIC8vIGl0ZW0sIGFuZCBmaXJlIGNoYW5nZWQgZXZlbnRzIG9uIHRoZW0gaWYgbmVjZXNzYXJ5LiAgVGhlbiB3ZSBmaXJlIGEgY2hhbmdlZFxuICAgIC8vIGV2ZW50IG9uIHRoZSBhbmNob3IsIGFuZCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGdyb3VwLiAgVGhlcmUgaXMgYWx3YXlzIGF0XG4gICAgLy8gbGVhc3Qgb25lIGdyb3VwOyB0aGUgbGFzdCBncm91cCBpcyBhbmNob3JlZCBieSBhIHZpcnR1YWwgXCJudWxsXCIgaWQgYXQgdGhlXG4gICAgLy8gZW5kLlxuXG4gICAgLy8gQXN5bXB0b3RpY2FsbHk6IE8oTiBrKSB3aGVyZSBrIGlzIG51bWJlciBvZiBvcHMsIG9yIHBvdGVudGlhbGx5XG4gICAgLy8gTyhOIGxvZyBOKSBpZiBpbm5lciBsb29wIG9mIExDUyB3ZXJlIG1hZGUgdG8gYmUgYmluYXJ5IHNlYXJjaC5cblxuXG4gICAgLy8vLy8vLy8gTENTIChsb25nZXN0IGNvbW1vbiBzZXF1ZW5jZSwgd2l0aCByZXNwZWN0IHRvIF9pZClcbiAgICAvLyAoc2VlIFdpa2lwZWRpYSBhcnRpY2xlIG9uIExvbmdlc3QgSW5jcmVhc2luZyBTdWJzZXF1ZW5jZSxcbiAgICAvLyB3aGVyZSB0aGUgTElTIGlzIHRha2VuIG9mIHRoZSBzZXF1ZW5jZSBvZiBvbGQgaW5kaWNlcyBvZiB0aGVcbiAgICAvLyBkb2NzIGluIG5ld19yZXN1bHRzKVxuICAgIC8vXG4gICAgLy8gdW5tb3ZlZDogdGhlIG91dHB1dCBvZiB0aGUgYWxnb3JpdGhtOyBtZW1iZXJzIG9mIHRoZSBMQ1MsXG4gICAgLy8gaW4gdGhlIGZvcm0gb2YgaW5kaWNlcyBpbnRvIG5ld19yZXN1bHRzXG4gICAgdmFyIHVubW92ZWQgPSBbXTtcbiAgICAvLyBtYXhfc2VxX2xlbjogbGVuZ3RoIG9mIExDUyBmb3VuZCBzbyBmYXJcbiAgICB2YXIgbWF4X3NlcV9sZW4gPSAwO1xuICAgIC8vIHNlcV9lbmRzW2ldOiB0aGUgaW5kZXggaW50byBuZXdfcmVzdWx0cyBvZiB0aGUgbGFzdCBkb2MgaW4gYVxuICAgIC8vIGNvbW1vbiBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggb2YgaSsxIDw9IG1heF9zZXFfbGVuXG4gICAgdmFyIE4gPSBuZXdfcmVzdWx0cy5sZW5ndGg7XG4gICAgdmFyIHNlcV9lbmRzID0gbmV3IEFycmF5KE4pO1xuICAgIC8vIHB0cnM6ICB0aGUgY29tbW9uIHN1YnNlcXVlbmNlIGVuZGluZyB3aXRoIG5ld19yZXN1bHRzW25dIGV4dGVuZHNcbiAgICAvLyBhIGNvbW1vbiBzdWJzZXF1ZW5jZSBlbmRpbmcgd2l0aCBuZXdfcmVzdWx0c1twdHJbbl1dLCB1bmxlc3NcbiAgICAvLyBwdHJbbl0gaXMgLTEuXG4gICAgdmFyIHB0cnMgPSBuZXcgQXJyYXkoTik7XG4gICAgLy8gdmlydHVhbCBzZXF1ZW5jZSBvZiBvbGQgaW5kaWNlcyBvZiBuZXcgcmVzdWx0c1xuICAgIHZhciBvbGRfaWR4X3NlcSA9IGZ1bmN0aW9uKGlfbmV3KSB7XG4gICAgICAgIHJldHVybiBvbGRfaW5kZXhfb2ZfaWRbbmV3X3Jlc3VsdHNbaV9uZXddLl9pZF07XG4gICAgfTtcbiAgICAvLyBmb3IgZWFjaCBpdGVtIGluIG5ld19yZXN1bHRzLCB1c2UgaXQgdG8gZXh0ZW5kIGEgY29tbW9uIHN1YnNlcXVlbmNlXG4gICAgLy8gb2YgbGVuZ3RoIGogPD0gbWF4X3NlcV9sZW5cbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspIHtcbiAgICAgICAgaWYgKG9sZF9pbmRleF9vZl9pZFtuZXdfcmVzdWx0c1tpXS5faWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBqID0gbWF4X3NlcV9sZW47XG4gICAgICAgICAgICAvLyB0aGlzIGlubmVyIGxvb3Agd291bGQgdHJhZGl0aW9uYWxseSBiZSBhIGJpbmFyeSBzZWFyY2gsXG4gICAgICAgICAgICAvLyBidXQgc2Nhbm5pbmcgYmFja3dhcmRzIHdlIHdpbGwgbGlrZWx5IGZpbmQgYSBzdWJzZXEgdG8gZXh0ZW5kXG4gICAgICAgICAgICAvLyBwcmV0dHkgc29vbiwgYm91bmRlZCBmb3IgZXhhbXBsZSBieSB0aGUgdG90YWwgbnVtYmVyIG9mIG9wcy5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2VyZSB0byBiZSBjaGFuZ2VkIHRvIGEgYmluYXJ5IHNlYXJjaCwgd2UnZCBzdGlsbCB3YW50XG4gICAgICAgICAgICAvLyB0byBzY2FuIGJhY2t3YXJkcyBhIGJpdCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkX2lkeF9zZXEoc2VxX2VuZHNbai0xXSkgPCBvbGRfaWR4X3NlcShpKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdHJzW2ldID0gKGogPT09IDAgPyAtMSA6IHNlcV9lbmRzW2otMV0pO1xuICAgICAgICAgICAgc2VxX2VuZHNbal0gPSBpO1xuICAgICAgICAgICAgaWYgKGorMSA+IG1heF9zZXFfbGVuKVxuICAgICAgICAgICAgICAgIG1heF9zZXFfbGVuID0gaisxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgdGhlIExDUy9MSVMgaW50byB1bm1vdmVkXG4gICAgdmFyIGlkeCA9IChtYXhfc2VxX2xlbiA9PT0gMCA/IC0xIDogc2VxX2VuZHNbbWF4X3NlcV9sZW4tMV0pO1xuICAgIHdoaWxlIChpZHggPj0gMCkge1xuICAgICAgICB1bm1vdmVkLnB1c2goaWR4KTtcbiAgICAgICAgaWR4ID0gcHRyc1tpZHhdO1xuICAgIH1cbiAgICAvLyB0aGUgdW5tb3ZlZCBpdGVtIGxpc3QgaXMgYnVpbHQgYmFja3dhcmRzLCBzbyBmaXggdGhhdFxuICAgIHVubW92ZWQucmV2ZXJzZSgpO1xuXG4gICAgLy8gdGhlIGxhc3QgZ3JvdXAgaXMgYWx3YXlzIGFuY2hvcmVkIGJ5IHRoZSBlbmQgb2YgdGhlIHJlc3VsdCBsaXN0LCB3aGljaCBpc1xuICAgIC8vIGFuIGlkIG9mIFwibnVsbFwiXG4gICAgdW5tb3ZlZC5wdXNoKG5ld19yZXN1bHRzLmxlbmd0aCk7XG5cbiAgICBvbGRfcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgaWYgKCFuZXdfcHJlc2VuY2Vfb2ZfaWRbZG9jLl9pZF0pXG4gICAgICAgICAgICBvYnNlcnZlci5yZW1vdmVkICYmIG9ic2VydmVyLnJlbW92ZWQoZG9jLl9pZCk7XG4gICAgfSk7XG5cbiAgICAvLyBmb3IgZWFjaCBncm91cCBvZiB0aGluZ3MgaW4gdGhlIG5ld19yZXN1bHRzIHRoYXQgaXMgYW5jaG9yZWQgYnkgYW4gdW5tb3ZlZFxuICAgIC8vIGVsZW1lbnQsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGhpbmdzIGJlZm9yZSBpdC5cbiAgICB2YXIgc3RhcnRPZkdyb3VwID0gMDtcbiAgICB1bm1vdmVkLmZvckVhY2goZnVuY3Rpb24gKGVuZE9mR3JvdXApIHtcbiAgICAgICAgdmFyIGdyb3VwSWQgPSBuZXdfcmVzdWx0c1tlbmRPZkdyb3VwXSA/IG5ld19yZXN1bHRzW2VuZE9mR3JvdXBdLl9pZCA6IG51bGw7XG4gICAgICAgIHZhciBvbGREb2MsIG5ld0RvYywgZmllbGRzLCBwcm9qZWN0ZWROZXcsIHByb2plY3RlZE9sZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0T2ZHcm91cDsgaSA8IGVuZE9mR3JvdXA7IGkrKykge1xuICAgICAgICAgICAgbmV3RG9jID0gbmV3X3Jlc3VsdHNbaV07XG4gICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKG9sZF9pbmRleF9vZl9pZCwgbmV3RG9jLl9pZCkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBwcm9qZWN0aW9uRm4obmV3RG9jKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZmllbGRzLl9pZDtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5hZGRlZEJlZm9yZSAmJiBvYnNlcnZlci5hZGRlZEJlZm9yZShuZXdEb2MuX2lkLCBmaWVsZHMsIGdyb3VwSWQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmFkZGVkICYmIG9ic2VydmVyLmFkZGVkKG5ld0RvYy5faWQsIGZpZWxkcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1vdmVkXG4gICAgICAgICAgICAgICAgb2xkRG9jID0gb2xkX3Jlc3VsdHNbb2xkX2luZGV4X29mX2lkW25ld0RvYy5faWRdXTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0ZWROZXcgPSBwcm9qZWN0aW9uRm4obmV3RG9jKTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0ZWRPbGQgPSBwcm9qZWN0aW9uRm4ob2xkRG9jKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBEaWZmU2VxdWVuY2UubWFrZUNoYW5nZWRGaWVsZHMocHJvamVjdGVkTmV3LCBwcm9qZWN0ZWRPbGQpO1xuICAgICAgICAgICAgICAgIGlmICghaXNPYmpFbXB0eShmaWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNoYW5nZWQgJiYgb2JzZXJ2ZXIuY2hhbmdlZChuZXdEb2MuX2lkLCBmaWVsZHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5tb3ZlZEJlZm9yZSAmJiBvYnNlcnZlci5tb3ZlZEJlZm9yZShuZXdEb2MuX2lkLCBncm91cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXBJZCkge1xuICAgICAgICAgICAgbmV3RG9jID0gbmV3X3Jlc3VsdHNbZW5kT2ZHcm91cF07XG4gICAgICAgICAgICBvbGREb2MgPSBvbGRfcmVzdWx0c1tvbGRfaW5kZXhfb2ZfaWRbbmV3RG9jLl9pZF1dO1xuICAgICAgICAgICAgcHJvamVjdGVkTmV3ID0gcHJvamVjdGlvbkZuKG5ld0RvYyk7XG4gICAgICAgICAgICBwcm9qZWN0ZWRPbGQgPSBwcm9qZWN0aW9uRm4ob2xkRG9jKTtcbiAgICAgICAgICAgIGZpZWxkcyA9IERpZmZTZXF1ZW5jZS5tYWtlQ2hhbmdlZEZpZWxkcyhwcm9qZWN0ZWROZXcsIHByb2plY3RlZE9sZCk7XG4gICAgICAgICAgICBpZiAoIWlzT2JqRW1wdHkoZmllbGRzKSkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNoYW5nZWQgJiYgb2JzZXJ2ZXIuY2hhbmdlZChuZXdEb2MuX2lkLCBmaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0T2ZHcm91cCA9IGVuZE9mR3JvdXArMTtcbiAgICB9KTtcblxuXG59O1xuXG5cbi8vIEdlbmVyYWwgaGVscGVyIGZvciBkaWZmLWluZyB0d28gb2JqZWN0cy5cbi8vIGNhbGxiYWNrcyBpcyBhbiBvYmplY3QgbGlrZSBzbzpcbi8vIHsgbGVmdE9ubHk6IGZ1bmN0aW9uIChrZXksIGxlZnRWYWx1ZSkgey4uLn0sXG4vLyAgIHJpZ2h0T25seTogZnVuY3Rpb24gKGtleSwgcmlnaHRWYWx1ZSkgey4uLn0sXG4vLyAgIGJvdGg6IGZ1bmN0aW9uIChrZXksIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSkgey4uLn0sXG4vLyB9XG5EaWZmU2VxdWVuY2UuZGlmZk9iamVjdHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGNhbGxiYWNrcykge1xuICAgIE9iamVjdC5rZXlzKGxlZnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgbGVmdFZhbHVlID0gbGVmdFtrZXldO1xuICAgICAgICBpZiAoaGFzT3duLmNhbGwocmlnaHQsIGtleSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5ib3RoICYmIGNhbGxiYWNrcy5ib3RoKGtleSwgbGVmdFZhbHVlLCByaWdodFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5sZWZ0T25seSAmJiBjYWxsYmFja3MubGVmdE9ubHkoa2V5LCBsZWZ0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY2FsbGJhY2tzLnJpZ2h0T25seSkge1xuICAgICAgICBPYmplY3Qua2V5cyhyaWdodCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRWYWx1ZSA9IHJpZ2h0W2tleV07XG4gICAgICAgICAgICBpZiAoISBoYXNPd24uY2FsbChsZWZ0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnJpZ2h0T25seShrZXksIHJpZ2h0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5EaWZmU2VxdWVuY2UuZGlmZk1hcHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGNhbGxiYWNrcykge1xuICAgIGxlZnQuZm9yRWFjaChmdW5jdGlvbiAobGVmdFZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHJpZ2h0LmhhcyhrZXkpKXtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5ib3RoICYmIGNhbGxiYWNrcy5ib3RoKGtleSwgbGVmdFZhbHVlLCByaWdodC5nZXQoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFja3MubGVmdE9ubHkgJiYgY2FsbGJhY2tzLmxlZnRPbmx5KGtleSwgbGVmdFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNhbGxiYWNrcy5yaWdodE9ubHkpIHtcbiAgICAgICAgcmlnaHQuZm9yRWFjaChmdW5jdGlvbiAocmlnaHRWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIWxlZnQuaGFzKGtleSkpe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5yaWdodE9ubHkoa2V5LCByaWdodFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG5EaWZmU2VxdWVuY2UubWFrZUNoYW5nZWRGaWVsZHMgPSBmdW5jdGlvbiAobmV3RG9jLCBvbGREb2MpIHtcbiAgICB2YXIgZmllbGRzID0ge307XG4gICAgRGlmZlNlcXVlbmNlLmRpZmZPYmplY3RzKG9sZERvYywgbmV3RG9jLCB7XG4gICAgICAgIGxlZnRPbmx5OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgZmllbGRzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0T25seTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGJvdGg6IGZ1bmN0aW9uIChrZXksIGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFFSlNPTi5lcXVhbHMobGVmdFZhbHVlLCByaWdodFZhbHVlKSlcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHJpZ2h0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmllbGRzO1xufTtcblxuRGlmZlNlcXVlbmNlLmFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChkb2MsIGNoYW5nZUZpZWxkcykge1xuICAgIE9iamVjdC5rZXlzKGNoYW5nZUZpZWxkcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZUZpZWxkc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgZG9jW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2Nba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuIl19